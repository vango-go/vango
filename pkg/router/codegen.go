package router

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// Generator generates Go code for registering routes.
type Generator struct {
	routes     []ScannedRoute
	modulePath string
}

// NewGenerator creates a new code generator.
func NewGenerator(routes []ScannedRoute, modulePath string) *Generator {
	// Sort routes for deterministic output
	sortedRoutes := make([]ScannedRoute, len(routes))
	copy(sortedRoutes, routes)
	sort.Slice(sortedRoutes, func(i, j int) bool {
		return sortedRoutes[i].Path < sortedRoutes[j].Path
	})

	return &Generator{
		routes:     sortedRoutes,
		modulePath: modulePath,
	}
}

// Generate produces the routes_gen.go file content.
// The output is deterministic - same input produces identical output.
func (g *Generator) Generate() ([]byte, error) {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by vango. DO NOT EDIT.\n\n")
	buf.WriteString("package routes\n\n")

	// Collect and sort imports for deterministic output
	imports := g.collectImports()
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			if imp.alias != "" {
				buf.WriteString(fmt.Sprintf("\t%s %q\n", imp.alias, imp.path))
			} else {
				buf.WriteString(fmt.Sprintf("\t%q\n", imp.path))
			}
		}
		buf.WriteString(")\n\n")
	}

	// Generate param structs for routes with parameters
	paramStructs := g.generateAllParamStructs()
	if len(paramStructs) > 0 {
		buf.WriteString(paramStructs)
		buf.WriteString("\n")
	}

	// Generate the Register function (Phase 14 spec format)
	g.generateRegisterFunction(&buf)

	// Generate route path constants for type-safe linking
	g.generateRouteConstants(&buf)

	return buf.Bytes(), nil
}

// generateRegisterFunction generates the Register function that registers all routes.
func (g *Generator) generateRegisterFunction(buf *bytes.Buffer) {
	buf.WriteString("// Register adds all routes to the app.\n")
	buf.WriteString("// Generated by `vango dev` or `vango gen routes`.\n")
	buf.WriteString("func Register(app *vango.App) {\n")

	// Group routes by type
	var layoutRoutes, middlewareRoutes, pageRoutes, apiRoutes []ScannedRoute
	for _, route := range g.routes {
		if route.HasLayout {
			layoutRoutes = append(layoutRoutes, route)
		}
		if route.HasMiddleware {
			middlewareRoutes = append(middlewareRoutes, route)
		}
		if route.HasPage {
			pageRoutes = append(pageRoutes, route)
		}
		if route.IsAPI && len(route.Methods) > 0 {
			apiRoutes = append(apiRoutes, route)
		}
	}

	sortByDepthThenPath(layoutRoutes)
	sortByDepthThenPath(middlewareRoutes)
	sortBySpecificityThenPath(pageRoutes)
	sortBySpecificityThenPath(apiRoutes)

	// Generate layout registration first
	if len(layoutRoutes) > 0 {
		buf.WriteString("\t// Layouts\n")
		for _, route := range layoutRoutes {
			g.generateLayoutRegistration(buf, route)
		}
		if len(middlewareRoutes) > 0 || len(pageRoutes) > 0 || len(apiRoutes) > 0 {
			buf.WriteString("\n")
		}
	}

	// Generate middleware registration
	if len(middlewareRoutes) > 0 {
		buf.WriteString("\t// Middleware\n")
		for _, route := range middlewareRoutes {
			g.generateMiddlewareRegistration(buf, route)
		}
		if len(pageRoutes) > 0 || len(apiRoutes) > 0 {
			buf.WriteString("\n")
		}
	}

	// Generate page routes
	if len(pageRoutes) > 0 {
		buf.WriteString("\t// Pages\n")
		for _, route := range pageRoutes {
			g.generatePageRegistration(buf, route)
		}
		if len(apiRoutes) > 0 {
			buf.WriteString("\n")
		}
	}

	// Generate API routes
	if len(apiRoutes) > 0 {
		buf.WriteString("\t// API routes\n")
		for _, route := range apiRoutes {
			g.generateAPIRegistration(buf, route)
		}
	}

	buf.WriteString("}\n\n")
}

// generateLayoutRegistration generates a single app.Layout() call.
func (g *Generator) generateLayoutRegistration(buf *bytes.Buffer, route ScannedRoute) {
	layoutName := g.getHandlerName(route)
	buf.WriteString(fmt.Sprintf("\tapp.Layout(%q, %s)\n", route.Path, layoutName))
}

func (g *Generator) generateMiddlewareRegistration(buf *bytes.Buffer, route ScannedRoute) {
	prefix := g.getPackagePrefix(route)
	mwExpr := prefix + "Middleware"
	if route.MiddlewareIsFunc || (!route.MiddlewareIsFunc && !route.MiddlewareIsVar) {
		mwExpr += "()"
	}
	buf.WriteString(fmt.Sprintf("\tapp.Middleware(%q, %s...)\n", route.Path, mwExpr))
}

// generatePageRegistration generates a single app.Page() call.
func (g *Generator) generatePageRegistration(buf *bytes.Buffer, route ScannedRoute) {
	// Determine handler name
	handlerName := g.getHandlerName(route)

	buf.WriteString(fmt.Sprintf("\tapp.Page(%q, %s)\n", route.Path, handlerName))
}

// generateAPIRegistration generates app.API() calls for API routes.
func (g *Generator) generateAPIRegistration(buf *bytes.Buffer, route ScannedRoute) {
	// Get package prefix if not in root routes package
	prefix := g.getPackagePrefix(route)

	methods := uniqueStrings(route.Methods)
	sort.Slice(methods, func(i, j int) bool {
		oi, okI := httpMethodOrder[methods[i]]
		oj, okJ := httpMethodOrder[methods[j]]
		if okI && okJ {
			return oi < oj
		}
		if okI != okJ {
			return okI
		}
		return methods[i] < methods[j]
	})

	for _, method := range methods {
		funcName := g.getAPIFuncName(route, method)
		if route.APIHandlers != nil {
			if name, ok := route.APIHandlers[method]; ok && name != "" {
				funcName = name
			}
		}
		buf.WriteString(fmt.Sprintf("\tapp.API(%q, %q, %s%s)\n",
			method, route.Path, prefix, funcName))
	}
}

// generateAllParamStructs generates all param structs.
func (g *Generator) generateAllParamStructs() string {
	var buf bytes.Buffer
	generated := make(map[string]bool)

	for _, route := range g.routes {
		if len(route.Params) > 0 {
			structName := g.pathToStructName(route.Path) + "Params"
			if generated[structName] {
				continue
			}
			generated[structName] = true
			g.generateParamStruct(&buf, route)
		}
	}

	return buf.String()
}

// generateRouteConstants generates route path constants.
func (g *Generator) generateRouteConstants(buf *bytes.Buffer) {
	var pageRoutes []ScannedRoute
	for _, route := range g.routes {
		if route.HasPage {
			pageRoutes = append(pageRoutes, route)
		}
	}

	if len(pageRoutes) == 0 {
		return
	}

	buf.WriteString("// Route path constants for type-safe linking.\n")
	buf.WriteString("const (\n")
	for _, route := range pageRoutes {
		constName := g.pathToConstName(route.Path)
		buf.WriteString(fmt.Sprintf("\tRoute%s = %q\n", constName, route.Path))
	}
	buf.WriteString(")\n")
}

// getHandlerName returns the handler function name for a route.
func (g *Generator) getHandlerName(route ScannedRoute) string {
	prefix := g.getPackagePrefix(route)

	// If the scanner found the actual handler name, use it
	if route.HandlerName != "" {
		return prefix + route.HandlerName
	}

	// Fall back to inferring from filename (for backwards compatibility)
	baseName := filepath.Base(strings.TrimSuffix(route.FilePath, ".go"))

	switch baseName {
	case "index":
		return prefix + "IndexPage"
	case "_layout":
		// Layout files export as "Layout" not "LayoutPage"
		return prefix + "Layout"
	case "layout":
		return prefix + "Layout"
	case "_middleware":
		return prefix + "Middleware"
	case "middleware":
		return prefix + "Middleware"
	default:
		// Check if it's a dynamic route [param]
		if strings.HasPrefix(baseName, "[") && strings.HasSuffix(baseName, "]") {
			// [id].go, [slug].go -> ShowPage per spec
			return prefix + "ShowPage"
		}
		// Remove any brackets and convert to PascalCase
		name := strings.ReplaceAll(baseName, "[", "")
		name = strings.ReplaceAll(name, "]", "")
		name = strings.ReplaceAll(name, "...", "")
		return prefix + g.toExportedName(name) + "Page"
	}
}

// getAPIFuncName returns the API handler function name.
func (g *Generator) getAPIFuncName(route ScannedRoute, method string) string {
	baseName := filepath.Base(strings.TrimSuffix(route.FilePath, ".go"))
	return g.toExportedName(baseName) + method
}

// getPackagePrefix returns the package prefix for a route.
func (g *Generator) getPackagePrefix(route ScannedRoute) string {
	if route.Package == "routes" {
		return ""
	}
	return route.Package + "."
}

var httpMethodOrder = map[string]int{
	"GET":     0,
	"POST":    1,
	"PUT":     2,
	"PATCH":   3,
	"DELETE":  4,
	"HEAD":    5,
	"OPTIONS": 6,
}

func sortByDepthThenPath(routes []ScannedRoute) {
	sort.SliceStable(routes, func(i, j int) bool {
		di := pathDepth(routes[i].Path)
		dj := pathDepth(routes[j].Path)
		if di != dj {
			return di < dj
		}
		return routes[i].Path < routes[j].Path
	})
}

func sortAPIRoutes(routes []ScannedRoute) {
	sortBySpecificityThenPath(routes)
}

func sortBySpecificityThenPath(routes []ScannedRoute) {
	sort.SliceStable(routes, func(i, j int) bool {
		si := calculateSpecificity(routes[i])
		sj := calculateSpecificity(routes[j])
		if si != sj {
			return si > sj
		}
		return routes[i].Path < routes[j].Path
	})
}

func uniqueStrings(in []string) []string {
	if len(in) == 0 {
		return nil
	}
	seen := make(map[string]struct{}, len(in))
	out := make([]string, 0, len(in))
	for _, s := range in {
		if _, ok := seen[s]; ok {
			continue
		}
		seen[s] = struct{}{}
		out = append(out, s)
	}
	return out
}

func pathDepth(path string) int {
	path = strings.Trim(path, "/")
	if path == "" {
		return 0
	}
	return strings.Count(path, "/") + 1
}

type importDef struct {
	alias string
	path  string
}

// collectImports gathers all required imports.
func (g *Generator) collectImports() []importDef {
	// Always import vango
	imports := []importDef{
		{path: "github.com/vango-go/vango"},
	}

	// Collect unique packages from routes that need to be imported
	// Routes in the root "routes" package don't need import (they're in the same package)
	packagePaths := make(map[string]bool)

	for _, route := range g.routes {
		if route.Package != "routes" && route.Package != "" {
			// Determine the import path for this package
			// The package is typically at {modulePath}/app/routes/{package}
			importPath := g.getPackageImportPath(route)
			if importPath != "" && !packagePaths[importPath] {
				packagePaths[importPath] = true
				imports = append(imports, importDef{path: importPath})
			}
		}
	}

	// Sort for deterministic output
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})

	return imports
}

// getPackageImportPath returns the Go import path for a route's package.
func (g *Generator) getPackageImportPath(route ScannedRoute) string {
	if route.Package == "routes" || route.Package == "" {
		return ""
	}

	// Derive package path from file path
	// FilePath is like "app/routes/api/health.go" or "/full/path/app/routes/admin/index.go"
	// We need to get "newapp/app/routes/api" or "newapp/app/routes/admin"
	dir := filepath.Dir(route.FilePath)

	// Find "app/routes" in the path and build import from there
	parts := strings.Split(filepath.ToSlash(dir), "/")
	appIdx := -1
	for i, part := range parts {
		if part == "app" && i+1 < len(parts) && parts[i+1] == "routes" {
			appIdx = i
			break
		}
	}

	if appIdx >= 0 {
		// Build the import path from "app/routes" onwards
		subPath := strings.Join(parts[appIdx:], "/")
		return g.modulePath + "/" + subPath
	}

	// Fallback: assume package is directly under routes
	return g.modulePath + "/app/routes/" + route.Package
}

// generateParamStruct generates a params struct for a route.
func (g *Generator) generateParamStruct(buf *bytes.Buffer, route ScannedRoute) {
	structName := g.pathToStructName(route.Path) + "Params"

	buf.WriteString(fmt.Sprintf("// %s holds parameters for %s.\n", structName, route.Path))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, param := range route.Params {
		goType := g.paramTypeToGoType(param.Type)
		fieldName := g.toExportedName(param.Name)
		buf.WriteString(fmt.Sprintf("\t%s %s `param:%q`\n", fieldName, goType, param.Name))
	}

	buf.WriteString("}\n\n")
}

// generateScannedRoute generates a ScannedRoute literal.
func (g *Generator) generateScannedRoute(buf *bytes.Buffer, route ScannedRoute) {
	buf.WriteString("\t{\n")
	buf.WriteString(fmt.Sprintf("\t\tPath:          %q,\n", route.Path))
	buf.WriteString(fmt.Sprintf("\t\tFilePath:      %q,\n", route.FilePath))
	buf.WriteString(fmt.Sprintf("\t\tPackage:       %q,\n", route.Package))
	buf.WriteString(fmt.Sprintf("\t\tHasPage:       %t,\n", route.HasPage))
	buf.WriteString(fmt.Sprintf("\t\tHasLayout:     %t,\n", route.HasLayout))
	buf.WriteString(fmt.Sprintf("\t\tHasMiddleware: %t,\n", route.HasMiddleware))
	buf.WriteString(fmt.Sprintf("\t\tIsAPI:         %t,\n", route.IsAPI))
	buf.WriteString(fmt.Sprintf("\t\tIsCatchAll:    %t,\n", route.IsCatchAll))

	if len(route.Methods) > 0 {
		buf.WriteString("\t\tMethods:       []string{")
		for i, m := range route.Methods {
			if i > 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(fmt.Sprintf("%q", m))
		}
		buf.WriteString("},\n")
	}

	if len(route.Params) > 0 {
		buf.WriteString("\t\tParams: []router.ParamDef{\n")
		for _, p := range route.Params {
			buf.WriteString(fmt.Sprintf("\t\t\t{Name: %q, Type: %q, Segment: %q},\n",
				p.Name, p.Type, p.Segment))
		}
		buf.WriteString("\t\t},\n")
	}

	buf.WriteString("\t},\n")
}

// pathToStructName converts a path to a valid Go struct name.
func (g *Generator) pathToStructName(path string) string {
	// Remove leading slash
	path = strings.TrimPrefix(path, "/")
	if path == "" {
		return "Index"
	}

	// Split by / and :
	parts := strings.FieldsFunc(path, func(r rune) bool {
		return r == '/' || r == ':' || r == '*'
	})

	var result strings.Builder
	for _, part := range parts {
		result.WriteString(g.toExportedName(part))
	}

	return result.String()
}

// pathToConstName converts a path to a valid Go constant name.
func (g *Generator) pathToConstName(path string) string {
	return g.pathToStructName(path)
}

// toExportedName converts a string to an exported Go identifier.
func (g *Generator) toExportedName(s string) string {
	if s == "" {
		return ""
	}

	// Handle common abbreviations
	upper := strings.ToUpper(s)
	switch upper {
	case "ID", "URL", "API", "HTTP", "UUID":
		return upper
	}

	// Title case the first letter
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

// paramTypeToGoType converts a param type annotation to a Go type.
func (g *Generator) paramTypeToGoType(paramType string) string {
	switch paramType {
	case "int":
		return "int"
	case "int64":
		return "int64"
	case "int32":
		return "int32"
	case "uint":
		return "uint"
	case "uint64":
		return "uint64"
	case "uuid":
		return "string" // UUIDs are stored as strings
	case "[]string":
		return "[]string" // Catch-all
	case "string", "":
		return "string"
	default:
		return "string"
	}
}

// packageAlias generates a unique package alias from a file path.
func (g *Generator) packageAlias(filePath string) string {
	dir := filepath.Dir(filePath)
	base := filepath.Base(dir)
	name := strings.TrimSuffix(filepath.Base(filePath), ".go")

	if name == "index" || name == "_layout" {
		return sanitizeIdentifier(base)
	}
	return sanitizeIdentifier(base + "_" + name)
}

// sanitizeIdentifier makes a string safe for use as a Go identifier.
func sanitizeIdentifier(s string) string {
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, "[", "")
	s = strings.ReplaceAll(s, "]", "")

	// Ensure it starts with a letter
	if len(s) > 0 && !unicode.IsLetter(rune(s[0])) {
		s = "r" + s
	}

	return s
}
