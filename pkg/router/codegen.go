package router

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// Generator generates Go code for registering routes.
type Generator struct {
	routes     []ScannedRoute
	modulePath string
}

// NewGenerator creates a new code generator.
func NewGenerator(routes []ScannedRoute, modulePath string) *Generator {
	// Sort routes for deterministic output
	sortedRoutes := make([]ScannedRoute, len(routes))
	copy(sortedRoutes, routes)
	sort.Slice(sortedRoutes, func(i, j int) bool {
		return sortedRoutes[i].Path < sortedRoutes[j].Path
	})

	return &Generator{
		routes:     sortedRoutes,
		modulePath: modulePath,
	}
}

// Generate produces the routes_gen.go file content.
// The output is deterministic - same input produces identical output.
func (g *Generator) Generate() ([]byte, error) {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by vango. DO NOT EDIT.\n\n")
	buf.WriteString("package routes\n\n")

	// Collect and sort imports for deterministic output
	imports := g.collectImports()
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			if imp.alias != "" {
				buf.WriteString(fmt.Sprintf("\t%s %q\n", imp.alias, imp.path))
			} else {
				buf.WriteString(fmt.Sprintf("\t%q\n", imp.path))
			}
		}
		buf.WriteString(")\n\n")
	}

	// Generate param structs for routes with parameters
	paramStructs := g.generateAllParamStructs()
	if len(paramStructs) > 0 {
		buf.WriteString(paramStructs)
		buf.WriteString("\n")
	}

	// Generate the Register function (Phase 14 spec format)
	g.generateRegisterFunction(&buf)

	// Generate route path constants for type-safe linking
	g.generateRouteConstants(&buf)

	return buf.Bytes(), nil
}

// generateRegisterFunction generates the Register function that registers all routes.
func (g *Generator) generateRegisterFunction(buf *bytes.Buffer) {
	buf.WriteString("// Register adds all routes to the router.\n")
	buf.WriteString("// Generated by `vango dev` or `vango gen routes`.\n")
	buf.WriteString("func Register(r *Router) {\n")

	// Group routes by type
	var pageRoutes, apiRoutes []ScannedRoute
	for _, route := range g.routes {
		if route.IsAPI || len(route.Methods) > 0 {
			apiRoutes = append(apiRoutes, route)
		} else if route.HasPage {
			pageRoutes = append(pageRoutes, route)
		}
	}

	// Generate page routes
	if len(pageRoutes) > 0 {
		buf.WriteString("\t// Page routes\n")
		for _, route := range pageRoutes {
			g.generatePageRegistration(buf, route)
		}
		if len(apiRoutes) > 0 {
			buf.WriteString("\n")
		}
	}

	// Generate API routes
	if len(apiRoutes) > 0 {
		buf.WriteString("\t// API routes\n")
		for _, route := range apiRoutes {
			g.generateAPIRegistration(buf, route)
		}
	}

	buf.WriteString("}\n\n")
}

// generatePageRegistration generates a single r.Page() call.
func (g *Generator) generatePageRegistration(buf *bytes.Buffer, route ScannedRoute) {
	// Determine handler name
	handlerName := g.getHandlerName(route)

	// Determine layout (if any)
	layoutName := ""
	if route.HasLayout {
		layoutName = ", Layout"
	} else {
		// Check for parent layout
		parentLayout := g.findParentLayout(route)
		if parentLayout != "" {
			layoutName = ", " + parentLayout
		}
	}

	// Determine middleware (if any)
	middlewareName := ""
	if route.HasMiddleware {
		middlewareName = ", Middleware..."
	}

	buf.WriteString(fmt.Sprintf("\tr.Page(%q, %s%s%s)\n",
		route.Path, handlerName, layoutName, middlewareName))
}

// generateAPIRegistration generates r.API() calls for API routes.
func (g *Generator) generateAPIRegistration(buf *bytes.Buffer, route ScannedRoute) {
	// Get package prefix if not in root routes package
	prefix := g.getPackagePrefix(route)

	for _, method := range route.Methods {
		funcName := g.getAPIFuncName(route, method)
		buf.WriteString(fmt.Sprintf("\tr.API(%q, %q, %s%s)\n",
			method, route.Path, prefix, funcName))
	}
}

// generateAllParamStructs generates all param structs.
func (g *Generator) generateAllParamStructs() string {
	var buf bytes.Buffer
	generated := make(map[string]bool)

	for _, route := range g.routes {
		if len(route.Params) > 0 {
			structName := g.pathToStructName(route.Path) + "Params"
			if generated[structName] {
				continue
			}
			generated[structName] = true
			g.generateParamStruct(&buf, route)
		}
	}

	return buf.String()
}

// generateRouteConstants generates route path constants.
func (g *Generator) generateRouteConstants(buf *bytes.Buffer) {
	var pageRoutes []ScannedRoute
	for _, route := range g.routes {
		if route.HasPage {
			pageRoutes = append(pageRoutes, route)
		}
	}

	if len(pageRoutes) == 0 {
		return
	}

	buf.WriteString("// Route path constants for type-safe linking.\n")
	buf.WriteString("const (\n")
	for _, route := range pageRoutes {
		constName := g.pathToConstName(route.Path)
		buf.WriteString(fmt.Sprintf("\tRoute%s = %q\n", constName, route.Path))
	}
	buf.WriteString(")\n")
}

// getHandlerName returns the handler function name for a route.
func (g *Generator) getHandlerName(route ScannedRoute) string {
	prefix := g.getPackagePrefix(route)

	// If the scanner found the actual handler name, use it
	if route.HandlerName != "" {
		return prefix + route.HandlerName
	}

	// Fall back to inferring from filename (for backwards compatibility)
	baseName := filepath.Base(strings.TrimSuffix(route.FilePath, ".go"))

	switch baseName {
	case "index":
		return prefix + "IndexPage"
	case "_layout":
		return prefix + "Layout"
	case "_middleware":
		return prefix + "Middleware"
	default:
		// Check if it's a dynamic route [param]
		if strings.HasPrefix(baseName, "[") && strings.HasSuffix(baseName, "]") {
			// [id].go, [slug].go -> ShowPage per spec
			return prefix + "ShowPage"
		}
		// Remove any brackets and convert to PascalCase
		name := strings.ReplaceAll(baseName, "[", "")
		name = strings.ReplaceAll(name, "]", "")
		name = strings.ReplaceAll(name, "...", "")
		return prefix + g.toExportedName(name) + "Page"
	}
}

// getAPIFuncName returns the API handler function name.
func (g *Generator) getAPIFuncName(route ScannedRoute, method string) string {
	baseName := filepath.Base(strings.TrimSuffix(route.FilePath, ".go"))
	return g.toExportedName(baseName) + method
}

// getPackagePrefix returns the package prefix for a route.
func (g *Generator) getPackagePrefix(route ScannedRoute) string {
	if route.Package == "routes" {
		return ""
	}
	return route.Package + "."
}

// findParentLayout finds a parent layout for a route.
func (g *Generator) findParentLayout(route ScannedRoute) string {
	// Simple implementation: check if root layout exists
	for _, r := range g.routes {
		if r.HasLayout && r.Path == "/" {
			return "Layout"
		}
	}
	return ""
}

type importDef struct {
	alias string
	path  string
}

// collectImports gathers all required imports.
func (g *Generator) collectImports() []importDef {
	// Always import router
	imports := []importDef{
		{path: "github.com/vango-go/vango/router"},
	}

	// Collect unique packages from routes that need to be imported
	// Routes in the root "routes" package don't need import (they're in the same package)
	packagePaths := make(map[string]bool)

	for _, route := range g.routes {
		if route.Package != "routes" && route.Package != "" {
			// Determine the import path for this package
			// The package is typically at {modulePath}/app/routes/{package}
			importPath := g.getPackageImportPath(route)
			if importPath != "" && !packagePaths[importPath] {
				packagePaths[importPath] = true
				imports = append(imports, importDef{path: importPath})
			}
		}
	}

	// Sort for deterministic output
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})

	return imports
}

// getPackageImportPath returns the Go import path for a route's package.
func (g *Generator) getPackageImportPath(route ScannedRoute) string {
	if route.Package == "routes" || route.Package == "" {
		return ""
	}

	// Derive package path from file path
	// FilePath is like "app/routes/api/health.go" or "/full/path/app/routes/admin/index.go"
	// We need to get "app/routes/api" or "app/routes/admin"
	dir := filepath.Dir(route.FilePath)

	// Find the routes directory and construct the import path
	// Look for "app/routes" or "routes" in the path
	parts := strings.Split(filepath.ToSlash(dir), "/")
	routesIdx := -1
	for i, part := range parts {
		if part == "routes" {
			routesIdx = i
			break
		}
	}

	if routesIdx >= 0 && routesIdx < len(parts)-1 {
		// Build the relative path from routes directory
		subPath := strings.Join(parts[routesIdx:], "/")
		return g.modulePath + "/" + subPath
	}

	// Fallback: assume package is directly under routes
	return g.modulePath + "/app/routes/" + route.Package
}

// generateParamStruct generates a params struct for a route.
func (g *Generator) generateParamStruct(buf *bytes.Buffer, route ScannedRoute) {
	structName := g.pathToStructName(route.Path) + "Params"

	buf.WriteString(fmt.Sprintf("// %s holds parameters for %s.\n", structName, route.Path))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, param := range route.Params {
		goType := g.paramTypeToGoType(param.Type)
		fieldName := g.toExportedName(param.Name)
		buf.WriteString(fmt.Sprintf("\t%s %s `param:%q`\n", fieldName, goType, param.Name))
	}

	buf.WriteString("}\n\n")
}

// generateScannedRoute generates a ScannedRoute literal.
func (g *Generator) generateScannedRoute(buf *bytes.Buffer, route ScannedRoute) {
	buf.WriteString("\t{\n")
	buf.WriteString(fmt.Sprintf("\t\tPath:          %q,\n", route.Path))
	buf.WriteString(fmt.Sprintf("\t\tFilePath:      %q,\n", route.FilePath))
	buf.WriteString(fmt.Sprintf("\t\tPackage:       %q,\n", route.Package))
	buf.WriteString(fmt.Sprintf("\t\tHasPage:       %t,\n", route.HasPage))
	buf.WriteString(fmt.Sprintf("\t\tHasLayout:     %t,\n", route.HasLayout))
	buf.WriteString(fmt.Sprintf("\t\tHasMiddleware: %t,\n", route.HasMiddleware))
	buf.WriteString(fmt.Sprintf("\t\tIsAPI:         %t,\n", route.IsAPI))
	buf.WriteString(fmt.Sprintf("\t\tIsCatchAll:    %t,\n", route.IsCatchAll))

	if len(route.Methods) > 0 {
		buf.WriteString("\t\tMethods:       []string{")
		for i, m := range route.Methods {
			if i > 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(fmt.Sprintf("%q", m))
		}
		buf.WriteString("},\n")
	}

	if len(route.Params) > 0 {
		buf.WriteString("\t\tParams: []router.ParamDef{\n")
		for _, p := range route.Params {
			buf.WriteString(fmt.Sprintf("\t\t\t{Name: %q, Type: %q, Segment: %q},\n",
				p.Name, p.Type, p.Segment))
		}
		buf.WriteString("\t\t},\n")
	}

	buf.WriteString("\t},\n")
}

// pathToStructName converts a path to a valid Go struct name.
func (g *Generator) pathToStructName(path string) string {
	// Remove leading slash
	path = strings.TrimPrefix(path, "/")
	if path == "" {
		return "Index"
	}

	// Split by / and :
	parts := strings.FieldsFunc(path, func(r rune) bool {
		return r == '/' || r == ':' || r == '*'
	})

	var result strings.Builder
	for _, part := range parts {
		result.WriteString(g.toExportedName(part))
	}

	return result.String()
}

// pathToConstName converts a path to a valid Go constant name.
func (g *Generator) pathToConstName(path string) string {
	return g.pathToStructName(path)
}

// toExportedName converts a string to an exported Go identifier.
func (g *Generator) toExportedName(s string) string {
	if s == "" {
		return ""
	}

	// Handle common abbreviations
	upper := strings.ToUpper(s)
	switch upper {
	case "ID", "URL", "API", "HTTP", "UUID":
		return upper
	}

	// Title case the first letter
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

// paramTypeToGoType converts a param type annotation to a Go type.
func (g *Generator) paramTypeToGoType(paramType string) string {
	switch paramType {
	case "int":
		return "int"
	case "int64":
		return "int64"
	case "int32":
		return "int32"
	case "uint":
		return "uint"
	case "uint64":
		return "uint64"
	case "uuid":
		return "string" // UUIDs are stored as strings
	case "[]string":
		return "[]string" // Catch-all
	case "string", "":
		return "string"
	default:
		return "string"
	}
}

// packageAlias generates a unique package alias from a file path.
func (g *Generator) packageAlias(filePath string) string {
	dir := filepath.Dir(filePath)
	base := filepath.Base(dir)
	name := strings.TrimSuffix(filepath.Base(filePath), ".go")

	if name == "index" || name == "_layout" {
		return sanitizeIdentifier(base)
	}
	return sanitizeIdentifier(base + "_" + name)
}

// sanitizeIdentifier makes a string safe for use as a Go identifier.
func sanitizeIdentifier(s string) string {
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, "[", "")
	s = strings.ReplaceAll(s, "]", "")

	// Ensure it starts with a letter
	if len(s) > 0 && !unicode.IsLetter(rune(s[0])) {
		s = "r" + s
	}

	return s
}
