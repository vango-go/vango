package router

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// Generator generates Go code for registering routes.
type Generator struct {
	routes     []ScannedRoute
	modulePath string
}

// NewGenerator creates a new code generator.
func NewGenerator(routes []ScannedRoute, modulePath string) *Generator {
	return &Generator{
		routes:     routes,
		modulePath: modulePath,
	}
}

// Generate produces the routes_gen.go file content.
func (g *Generator) Generate() ([]byte, error) {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by vango gen routes. DO NOT EDIT.\n\n")
	buf.WriteString("package routes\n\n")

	// Collect imports
	imports := g.collectImports()
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			if imp.alias != "" {
				buf.WriteString(fmt.Sprintf("\t%s %q\n", imp.alias, imp.path))
			} else {
				buf.WriteString(fmt.Sprintf("\t%q\n", imp.path))
			}
		}
		buf.WriteString(")\n\n")
	}

	// Generate param structs
	for _, route := range g.routes {
		if len(route.Params) > 0 {
			g.generateParamStruct(&buf, route)
		}
	}

	// Generate registration function
	buf.WriteString("// RegisterRoutes registers all routes with the router.\n")
	buf.WriteString("func RegisterRoutes(r *router.Router, registry *router.HandlerRegistry) {\n")
	buf.WriteString("\tr.BuildFromScanned(scannedRoutes, registry)\n")
	buf.WriteString("}\n\n")

	// Generate scanned routes slice
	buf.WriteString("// scannedRoutes contains all discovered routes.\n")
	buf.WriteString("var scannedRoutes = []router.ScannedRoute{\n")
	for _, route := range g.routes {
		g.generateScannedRoute(&buf, route)
	}
	buf.WriteString("}\n\n")

	// Generate route paths as constants for type-safe linking
	buf.WriteString("// Route path constants for type-safe linking.\n")
	buf.WriteString("const (\n")
	for _, route := range g.routes {
		if route.HasPage {
			constName := g.pathToConstName(route.Path)
			buf.WriteString(fmt.Sprintf("\tRoute%s = %q\n", constName, route.Path))
		}
	}
	buf.WriteString(")\n")

	return buf.Bytes(), nil
}

type importDef struct {
	alias string
	path  string
}

// collectImports gathers all required imports.
func (g *Generator) collectImports() []importDef {
	imports := []importDef{
		{path: g.modulePath + "/pkg/router"},
	}

	// Sort for deterministic output
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})

	return imports
}

// generateParamStruct generates a params struct for a route.
func (g *Generator) generateParamStruct(buf *bytes.Buffer, route ScannedRoute) {
	structName := g.pathToStructName(route.Path) + "Params"

	buf.WriteString(fmt.Sprintf("// %s holds parameters for %s.\n", structName, route.Path))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, param := range route.Params {
		goType := g.paramTypeToGoType(param.Type)
		fieldName := g.toExportedName(param.Name)
		buf.WriteString(fmt.Sprintf("\t%s %s `param:%q`\n", fieldName, goType, param.Name))
	}

	buf.WriteString("}\n\n")
}

// generateScannedRoute generates a ScannedRoute literal.
func (g *Generator) generateScannedRoute(buf *bytes.Buffer, route ScannedRoute) {
	buf.WriteString("\t{\n")
	buf.WriteString(fmt.Sprintf("\t\tPath:          %q,\n", route.Path))
	buf.WriteString(fmt.Sprintf("\t\tFilePath:      %q,\n", route.FilePath))
	buf.WriteString(fmt.Sprintf("\t\tPackage:       %q,\n", route.Package))
	buf.WriteString(fmt.Sprintf("\t\tHasPage:       %t,\n", route.HasPage))
	buf.WriteString(fmt.Sprintf("\t\tHasLayout:     %t,\n", route.HasLayout))
	buf.WriteString(fmt.Sprintf("\t\tHasMiddleware: %t,\n", route.HasMiddleware))
	buf.WriteString(fmt.Sprintf("\t\tIsAPI:         %t,\n", route.IsAPI))
	buf.WriteString(fmt.Sprintf("\t\tIsCatchAll:    %t,\n", route.IsCatchAll))

	if len(route.Methods) > 0 {
		buf.WriteString("\t\tMethods:       []string{")
		for i, m := range route.Methods {
			if i > 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(fmt.Sprintf("%q", m))
		}
		buf.WriteString("},\n")
	}

	if len(route.Params) > 0 {
		buf.WriteString("\t\tParams: []router.ParamDef{\n")
		for _, p := range route.Params {
			buf.WriteString(fmt.Sprintf("\t\t\t{Name: %q, Type: %q, Segment: %q},\n",
				p.Name, p.Type, p.Segment))
		}
		buf.WriteString("\t\t},\n")
	}

	buf.WriteString("\t},\n")
}

// pathToStructName converts a path to a valid Go struct name.
func (g *Generator) pathToStructName(path string) string {
	// Remove leading slash
	path = strings.TrimPrefix(path, "/")
	if path == "" {
		return "Index"
	}

	// Split by / and :
	parts := strings.FieldsFunc(path, func(r rune) bool {
		return r == '/' || r == ':' || r == '*'
	})

	var result strings.Builder
	for _, part := range parts {
		result.WriteString(g.toExportedName(part))
	}

	return result.String()
}

// pathToConstName converts a path to a valid Go constant name.
func (g *Generator) pathToConstName(path string) string {
	return g.pathToStructName(path)
}

// toExportedName converts a string to an exported Go identifier.
func (g *Generator) toExportedName(s string) string {
	if s == "" {
		return ""
	}

	// Handle common abbreviations
	upper := strings.ToUpper(s)
	switch upper {
	case "ID", "URL", "API", "HTTP", "UUID":
		return upper
	}

	// Title case the first letter
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

// paramTypeToGoType converts a param type annotation to a Go type.
func (g *Generator) paramTypeToGoType(paramType string) string {
	switch paramType {
	case "int":
		return "int"
	case "int64":
		return "int64"
	case "int32":
		return "int32"
	case "uint":
		return "uint"
	case "uint64":
		return "uint64"
	case "uuid":
		return "string" // UUIDs are stored as strings
	case "[]string":
		return "[]string" // Catch-all
	case "string", "":
		return "string"
	default:
		return "string"
	}
}

// packageAlias generates a unique package alias from a file path.
func (g *Generator) packageAlias(filePath string) string {
	dir := filepath.Dir(filePath)
	base := filepath.Base(dir)
	name := strings.TrimSuffix(filepath.Base(filePath), ".go")

	if name == "index" || name == "_layout" {
		return sanitizeIdentifier(base)
	}
	return sanitizeIdentifier(base + "_" + name)
}

// sanitizeIdentifier makes a string safe for use as a Go identifier.
func sanitizeIdentifier(s string) string {
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, "[", "")
	s = strings.ReplaceAll(s, "]", "")

	// Ensure it starts with a letter
	if len(s) > 0 && !unicode.IsLetter(rune(s[0])) {
		s = "r" + s
	}

	return s
}
