package router

import (
	"strings"
	"testing"
)

func TestGeneratorGenerate(t *testing.T) {
	routes := []ScannedRoute{
		{
			Path:     "/",
			FilePath: "index.go",
			Package:  "routes",
			HasPage:  true,
		},
		{
			Path:     "/about",
			FilePath: "about.go",
			Package:  "routes",
			HasPage:  true,
			HasMeta:  true,
		},
		{
			Path:          "/users/:id",
			FilePath:      "users/[id].go",
			Package:       "routes",
			HasPage:       true,
			HasMiddleware: true,
			Params: []ParamDef{
				{Name: "id", Type: "int", Segment: "[id]"},
			},
		},
		{
			Path:     "/api/users",
			FilePath: "api/users.go",
			Package:  "api",
			IsAPI:    true,
			Methods:  []string{"GET", "POST"},
		},
		{
			Path:       "/docs/*path",
			FilePath:   "docs/[...path].go",
			Package:    "routes",
			HasPage:    true,
			IsCatchAll: true,
			Params: []ParamDef{
				{Name: "path", Type: "[]string", Segment: "[...path]"},
			},
		},
	}

	gen := NewGenerator(routes, "github.com/example/app")
	output, err := gen.Generate()
	if err != nil {
		t.Fatalf("Generate() error: %v", err)
	}

	code := string(output)

	// Check header
	if !strings.Contains(code, "Code generated by vango gen routes. DO NOT EDIT.") {
		t.Error("missing generated header")
	}

	// Check package
	if !strings.Contains(code, "package routes") {
		t.Error("missing package declaration")
	}

	// Check imports
	if !strings.Contains(code, `"github.com/example/app/pkg/router"`) {
		t.Error("missing router import")
	}

	// Check param structs - uses ID abbreviation handling
	if !strings.Contains(code, "type UsersIDParams struct") {
		t.Error("missing UsersIDParams struct")
	}
	if !strings.Contains(code, `ID int`) {
		t.Error("missing ID field in UsersIDParams")
	}

	// Check catch-all param struct
	if !strings.Contains(code, "type DocsPathParams struct") {
		t.Error("missing DocsPathParams struct")
	}
	if !strings.Contains(code, `Path []string`) {
		t.Error("missing Path field in DocsPathParams")
	}

	// Check RegisterRoutes function
	if !strings.Contains(code, "func RegisterRoutes(r *router.Router, registry *router.HandlerRegistry)") {
		t.Error("missing RegisterRoutes function")
	}

	// Check scannedRoutes
	if !strings.Contains(code, "var scannedRoutes = []router.ScannedRoute{") {
		t.Error("missing scannedRoutes variable")
	}

	// Check route entries
	if !strings.Contains(code, `Path:          "/"`) {
		t.Error("missing / route")
	}
	if !strings.Contains(code, `Path:          "/about"`) {
		t.Error("missing /about route")
	}

	// Check route constants
	if !strings.Contains(code, "const (") {
		t.Error("missing route constants")
	}
	if !strings.Contains(code, `RouteIndex = "/"`) {
		t.Error("missing RouteIndex constant")
	}
	if !strings.Contains(code, `RouteAbout = "/about"`) {
		t.Error("missing RouteAbout constant")
	}
}

func TestGeneratorPathToStructName(t *testing.T) {
	gen := NewGenerator(nil, "")

	tests := []struct {
		path string
		want string
	}{
		{"/", "Index"},
		{"/about", "About"},
		{"/users/:id", "UsersID"},
		{"/users/:userId/posts/:postId", "UsersUserIdPostsPostId"},
		{"/*slug", "Slug"},
		{"/docs/*path", "DocsPath"},
	}

	for _, tt := range tests {
		got := gen.pathToStructName(tt.path)
		if got != tt.want {
			t.Errorf("pathToStructName(%q) = %q, want %q", tt.path, got, tt.want)
		}
	}
}

func TestGeneratorToExportedName(t *testing.T) {
	gen := NewGenerator(nil, "")

	tests := []struct {
		input string
		want  string
	}{
		{"id", "ID"}, // "id" is a common abbreviation
		{"ID", "ID"},
		{"userId", "UserId"},
		{"url", "URL"},
		{"api", "API"},
		{"uuid", "UUID"},
		{"http", "HTTP"},
	}

	for _, tt := range tests {
		got := gen.toExportedName(tt.input)
		if got != tt.want {
			t.Errorf("toExportedName(%q) = %q, want %q", tt.input, got, tt.want)
		}
	}
}

func TestGeneratorParamTypeToGoType(t *testing.T) {
	gen := NewGenerator(nil, "")

	tests := []struct {
		paramType string
		want      string
	}{
		{"int", "int"},
		{"int64", "int64"},
		{"int32", "int32"},
		{"uint", "uint"},
		{"uint64", "uint64"},
		{"uuid", "string"},
		{"string", "string"},
		{"", "string"},
		{"[]string", "[]string"},
		{"unknown", "string"},
	}

	for _, tt := range tests {
		got := gen.paramTypeToGoType(tt.paramType)
		if got != tt.want {
			t.Errorf("paramTypeToGoType(%q) = %q, want %q", tt.paramType, got, tt.want)
		}
	}
}

func TestSanitizeIdentifier(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{"users", "users"},
		{"user-profile", "user_profile"},
		{"my.route", "my_route"},
		{"[id]", "id"},
		{"123start", "r123start"},
	}

	for _, tt := range tests {
		got := sanitizeIdentifier(tt.input)
		if got != tt.want {
			t.Errorf("sanitizeIdentifier(%q) = %q, want %q", tt.input, got, tt.want)
		}
	}
}
