package templates

func applyAuthScaffold(t *Template) {
	replaceTemplateFile(t, "main.go", authMainGo)
	replaceTemplateFile(t, "app/routes/routes_gen.go", authRoutesGen)
	replaceTemplateFile(t, "app/components/shared/navbar.go", authNavbarGo)

	t.files = append(t.files,
		templateFile{Path: "app/authstore/store.go", Content: authStoreGo},
		templateFile{Path: "app/authstore/http.go", Content: authHTTPGo},
		templateFile{Path: "app/routes/login.go", Content: authLoginGo},
		templateFile{Path: "app/routes/admin.go", Content: authAdminGo},
	)
}

const authMainGo = `package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/vango-go/vango"
	"github.com/vango-go/vango/pkg/auth"
	"github.com/vango-go/vango/pkg/auth/sessionauth"
	"{{.ProjectName}}/app/authstore"
	"{{.ProjectName}}/app/routes"
)

func main() {
	store, err := authstore.NewMemoryStore()
	if err != nil {
		log.Fatal(err)
	}

	provider := sessionauth.New(store, sessionauth.WithCookieName(authstore.SessionCookieName))

	app := vango.New(vango.Config{
		Session: vango.SessionConfig{
			ResumeWindow: 30 * time.Second,
			AuthCheck: &vango.AuthCheckConfig{
				Interval: 2 * time.Minute,
				Check:    provider.Verify,
				OnExpired: vango.AuthExpiredConfig{
					Action: vango.ForceReload,
				},
			},
		},
		Static: vango.StaticConfig{
			Dir:    "public",
			Prefix: "/",
		},
		DevMode: os.Getenv("ENVIRONMENT") != "production",
		OnSessionStart: func(httpCtx context.Context, s *vango.Session) {
			hydrateSession(httpCtx, s, provider)
		},
		OnSessionResume: func(httpCtx context.Context, s *vango.Session) error {
			hydrateSession(httpCtx, s, provider)
			return nil
		},
	})

	routes.Register(app)

	appHandler := provider.Middleware()(app)

	mux := http.NewServeMux()
	mux.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodPost {
			authstore.LoginHandler(store)(w, r)
			return
		}
		appHandler.ServeHTTP(w, r)
	})
	mux.HandleFunc("/logout", authstore.LogoutHandler(store))
	mux.Handle("/", appHandler)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Server starting on http://localhost:%s", port)
	log.Fatal(http.ListenAndServe(":"+port, mux))
}

func hydrateSession(httpCtx context.Context, s *vango.Session, provider *sessionauth.Provider) {
	stored, ok := sessionauth.SessionFromContext(httpCtx)
	if !ok {
		return
	}
	principal, ok := provider.Principal(httpCtx)
	if !ok {
		return
	}
	if user := authstore.UserFromStored(stored); user != nil {
		auth.Set(s, user)
	}
	auth.SetPrincipal(s, principal)
}
`

const authRoutesGen = `// Code generated by vango. DO NOT EDIT.

package routes

import (
	"github.com/vango-go/vango"
	"github.com/vango-go/vango/pkg/authmw"
	"{{.ProjectName}}/app/routes/api"
)

func Register(app *vango.App) {
	// Register root layout - all pages inherit this
	app.Layout("/", Layout)

	// Pages (inherit root layout automatically)
	app.Page("/", IndexPage)
	app.Page("/about", AboutPage)
	app.Page("/login", LoginPage)
	app.Page("/admin", AdminPage)

	// Route-level auth
	app.Middleware("/admin", authmw.RequireAuth)

	// API routes
	app.API("GET", "/api/health", api.HealthGET)
}
`

const authNavbarGo = `package shared

import (
	"github.com/vango-go/vango"
	"github.com/vango-go/vango/pkg/auth"
	. "github.com/vango-go/vango/el"

	"{{.ProjectName}}/app/authstore"
)

func Navbar(ctx vango.Ctx) *vango.VNode {
	user, ok := auth.Get[*authstore.User](ctx)
	authenticated := ok && user != nil

	return Header(Class("border-b border-gray-200 dark:border-gray-700"),
		Div(Class("max-w-5xl mx-auto px-5 py-4 flex items-center justify-between"),
			// Logo and brand
			Div(Class("flex items-center gap-3"),
				Img(Src("/logo.svg"), Alt("Vango"), Class("h-8 w-8")),
				Link("/", Class("font-bold text-lg hover:opacity-80 transition-opacity"), Text("{{.ProjectName}}")),
			),
			// Navigation
			Div(Class("flex items-center gap-6"),
				Nav(Class("flex items-center gap-4"),
					NavLink(ctx, "/", Text("Home")),
					NavLink(ctx, "/about", Text("About")),
					If(authenticated, NavLink(ctx, "/admin", Text("Admin"))),
					If(!authenticated, NavLink(ctx, "/login", Text("Login"))),
				),
				If(authenticated, Link("/logout", Class("text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white"), Text("Logout"))),
				ThemeToggle(),
			),
		),
	)
}

func ThemeToggle() *vango.VNode {
	return Button(
		ID("theme-toggle"),
		Type("button"),
		Data("hook", "ThemeToggle"),
		Data("hook-config", ` + "`" + `{"storageKey":"theme"}` + "`" + `),
		Class("p-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors"),
		AriaLabel("Toggle theme"),
		// Sun icon (shown in dark mode)
		Span(Class("hidden dark:block"),
			Raw(` + "`" + `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>` + "`" + `),
		),
		// Moon icon (shown in light mode)
		Span(Class("block dark:hidden"),
			Raw(` + "`" + `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>` + "`" + `),
		),
	)
}
`

const authStoreGo = `package authstore

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"errors"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/vango-go/vango/pkg/auth"
	"github.com/vango-go/vango/pkg/auth/sessionauth"
	"golang.org/x/crypto/bcrypt"
)

const SessionCookieName = "session"

var ErrInvalidCredentials = errors.New("invalid credentials")

type User struct {
	ID    string
	Email string
	Name  string
	Roles []string
}

type MemoryStore struct {
	mu       sync.RWMutex
	sessions map[string]*sessionauth.StoredSession
	users    map[string]*userRecord
}

type userRecord struct {
	user        User
	passwordHash []byte
	authVersion int
}

func NewMemoryStore() (*MemoryStore, error) {
	store := &MemoryStore{
		sessions: make(map[string]*sessionauth.StoredSession),
		users:    make(map[string]*userRecord),
	}

	email := envOrDefault("VANGO_ADMIN_EMAIL", "admin@example.com")
	password := envOrDefault("VANGO_ADMIN_PASSWORD", "admin123")
	name := envOrDefault("VANGO_ADMIN_NAME", "Admin")

	if err := store.addUser(email, password, name, []string{"admin"}); err != nil {
		return nil, err
	}

	return store, nil
}

func (s *MemoryStore) addUser(email, password, name string, roles []string) error {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	id := strings.ToLower(email)
	s.users[id] = &userRecord{
		user: User{
			ID:    id,
			Email: email,
			Name:  name,
			Roles: roles,
		},
		passwordHash: hash,
		authVersion:  1,
	}
	return nil
}

func (s *MemoryStore) Authenticate(email, password string) (*User, error) {
	if email == "" || password == "" {
		return nil, ErrInvalidCredentials
	}

	s.mu.RLock()
	record, ok := s.users[strings.ToLower(email)]
	s.mu.RUnlock()
	if !ok {
		return nil, ErrInvalidCredentials
	}

	if err := bcrypt.CompareHashAndPassword(record.passwordHash, []byte(password)); err != nil {
		return nil, ErrInvalidCredentials
	}

	user := record.user
	return &user, nil
}

func (s *MemoryStore) CreateSession(user *User) (*sessionauth.StoredSession, error) {
	if user == nil {
		return nil, errors.New("user is nil")
	}

	sessionID, err := generateSessionID()
	if err != nil {
		return nil, err
	}

	s.mu.RLock()
	record, ok := s.users[strings.ToLower(user.Email)]
	s.mu.RUnlock()
	if !ok {
		return nil, auth.ErrSessionRevoked
	}

	stored := &sessionauth.StoredSession{
		ID:          sessionID,
		UserID:      record.user.ID,
		Email:       record.user.Email,
		Name:        record.user.Name,
		Roles:       record.user.Roles,
		TenantID:    "",
		ExpiresAt:   time.Now().Add(24 * time.Hour),
		AuthVersion: record.authVersion,
	}

	s.mu.Lock()
	s.sessions[sessionID] = stored
	s.mu.Unlock()

	return stored, nil
}

func (s *MemoryStore) Get(_ context.Context, sessionID string) (*sessionauth.StoredSession, error) {
	if sessionID == "" {
		return nil, auth.ErrSessionRevoked
	}

	s.mu.RLock()
	stored, ok := s.sessions[sessionID]
	s.mu.RUnlock()
	if !ok {
		return nil, auth.ErrSessionRevoked
	}
	return stored, nil
}

func (s *MemoryStore) Validate(_ context.Context, stored *sessionauth.StoredSession) error {
	if stored == nil {
		return auth.ErrSessionRevoked
	}

	if time.Now().After(stored.ExpiresAt) {
		return auth.ErrSessionExpired
	}

	s.mu.RLock()
	record, ok := s.users[strings.ToLower(stored.Email)]
	s.mu.RUnlock()
	if !ok || record.authVersion != stored.AuthVersion {
		return auth.ErrSessionRevoked
	}

	return nil
}

func (s *MemoryStore) Delete(sessionID string) {
	if sessionID == "" {
		return
	}
	s.mu.Lock()
	delete(s.sessions, sessionID)
	s.mu.Unlock()
}

func UserFromStored(stored *sessionauth.StoredSession) *User {
	if stored == nil {
		return nil
	}
	return &User{
		ID:    stored.UserID,
		Email: stored.Email,
		Name:  stored.Name,
		Roles: stored.Roles,
	}
}

func generateSessionID() (string, error) {
	b := make([]byte, 16)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return hex.EncodeToString(b), nil
}

func envOrDefault(key, fallback string) string {
	if val := os.Getenv(key); val != "" {
		return val
	}
	return fallback
}
`

const authHTTPGo = `package authstore

import (
	"net/http"
)

func LoginHandler(store *MemoryStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
			return
		}

		if err := r.ParseForm(); err != nil {
			http.Error(w, "invalid form", http.StatusBadRequest)
			return
		}

		email := r.FormValue("email")
		password := r.FormValue("password")

		user, err := store.Authenticate(email, password)
		if err != nil {
			http.Redirect(w, r, "/login?error=invalid", http.StatusSeeOther)
			return
		}

		stored, err := store.CreateSession(user)
		if err != nil {
			http.Error(w, "failed to create session", http.StatusInternalServerError)
			return
		}

		cookie := &http.Cookie{
			Name:     SessionCookieName,
			Value:    stored.ID,
			Path:     "/",
			Expires:  stored.ExpiresAt,
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			Secure:   isSecureRequest(r),
		}
		http.SetCookie(w, cookie)

		http.Redirect(w, r, "/admin", http.StatusSeeOther)
	}
}

func LogoutHandler(store *MemoryStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if c, err := r.Cookie(SessionCookieName); err == nil {
			store.Delete(c.Value)
		}

		cookie := &http.Cookie{
			Name:     SessionCookieName,
			Value:    "",
			Path:     "/",
			MaxAge:   -1,
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			Secure:   isSecureRequest(r),
		}
		http.SetCookie(w, cookie)

		http.Redirect(w, r, "/", http.StatusSeeOther)
	}
}

func isSecureRequest(r *http.Request) bool {
	if r == nil {
		return false
	}
	if r.TLS != nil {
		return true
	}
	if r.Header.Get("X-Forwarded-Proto") == "https" {
		return true
	}
	return false
}
`

const authLoginGo = `package routes

import (
	"github.com/vango-go/vango"
	"github.com/vango-go/vango/pkg/auth"
	. "github.com/vango-go/vango/el"

	"{{.ProjectName}}/app/authstore"
)

func LoginPage(ctx vango.Ctx) *vango.VNode {
	if user, ok := auth.Get[*authstore.User](ctx); ok && user != nil {
		return Div(Class("max-w-xl space-y-4"),
			H1(Class("text-2xl font-bold"), Text("You're already signed in")),
			P(Class("text-gray-600 dark:text-gray-400"), Textf("Signed in as %s", user.Email)),
			Div(Class("flex gap-3"),
				Link("/admin", Class("text-blue-600 dark:text-blue-400 hover:underline"), Text("Go to Admin")),
				Link("/logout", Class("text-blue-600 dark:text-blue-400 hover:underline"), Text("Log out")),
			),
		)
	}

	var errText string
	if ctx.QueryParam("error") == "invalid" {
		errText = "Invalid email or password."
	}

	return Div(Class("max-w-md space-y-6"),
		H1(Class("text-3xl font-bold"), Text("Sign in")),
		P(Class("text-gray-600 dark:text-gray-400"), Text("Use the default admin credentials or update them in environment variables.")),
		If(errText != "", P(Class("text-red-600"), Text(errText))),
		Form(Action("/login"), Method("post"), Class("space-y-4"),
			Div(Class("space-y-2"),
				Label(Class("block text-sm font-medium"), Text("Email")),
				Input(Type("email"), Name("email"), Required(), Class("w-full border border-gray-300 dark:border-gray-600 rounded px-3 py-2 bg-white dark:bg-gray-800")),
			),
			Div(Class("space-y-2"),
				Label(Class("block text-sm font-medium"), Text("Password")),
				Input(Type("password"), Name("password"), Required(), Class("w-full border border-gray-300 dark:border-gray-600 rounded px-3 py-2 bg-white dark:bg-gray-800")),
			),
			Button(Type("submit"), Class("w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"), Text("Sign in")),
		),
		Div(Class("text-sm text-gray-500"),
			P(Text("Default admin credentials:")),
			Ul(Class("list-disc list-inside"),
				Li(Text("Email: admin@example.com")),
				Li(Text("Password: admin123")),
			),
		),
	)
}
`

const authAdminGo = `package routes

import (
	"github.com/vango-go/vango"
	"github.com/vango-go/vango/pkg/auth"
	. "github.com/vango-go/vango/el"

	"{{.ProjectName}}/app/authstore"
)

func AdminPage(ctx vango.Ctx) *vango.VNode {
	user, _ := auth.Get[*authstore.User](ctx)
	name := "Admin"
	if user != nil {
		if user.Name != "" {
			name = user.Name
		} else if user.Email != "" {
			name = user.Email
		}
	}

	return Div(Class("space-y-4"),
		H1(Class("text-3xl font-bold"), Text("Admin Dashboard")),
		P(Class("text-gray-600 dark:text-gray-400"), Textf("Welcome, %s.", name)),
		Link("/logout", Class("text-blue-600 dark:text-blue-400 hover:underline"), Text("Log out")),
	)
}
`
