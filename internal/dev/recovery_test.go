package dev

import (
	"os"
	"path/filepath"
	"testing"
)

func TestIsRecoverableError(t *testing.T) {
	tests := []struct {
		name        string
		buildOutput string
		want        bool
	}{
		{
			name:        "undefined symbol in routes_gen.go",
			buildOutput: "./app/routes/routes_gen.go:15:12: undefined: IndexPage",
			want:        true,
		},
		{
			name:        "multiple undefined symbols",
			buildOutput: "./app/routes/routes_gen.go:15:12: undefined: IndexPage\n./app/routes/routes_gen.go:16:12: undefined: AboutPage",
			want:        true,
		},
		{
			name:        "missing import in routes",
			buildOutput: `could not import my-app/app/routes/admin (no required module provides package)`,
			want:        true,
		},
		{
			name:        "regular undefined symbol",
			buildOutput: "./app/components/button.go:10:5: undefined: SomeFunc",
			want:        false,
		},
		{
			name:        "syntax error",
			buildOutput: "./main.go:5:1: expected 'package', found 'EOF'",
			want:        false,
		},
		{
			name:        "empty output",
			buildOutput: "",
			want:        false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsRecoverableError(tt.buildOutput)
			if got != tt.want {
				t.Errorf("IsRecoverableError() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestErrorRecovery_UndefinedSymbols(t *testing.T) {
	// Create a temporary project structure
	tmpDir := t.TempDir()
	routesDir := filepath.Join(tmpDir, "app", "routes")
	os.MkdirAll(routesDir, 0755)

	// Create a route file with a new handler name (simulating rename)
	indexGo := `package routes

import (
	"github.com/vango-go/vango"
	. "github.com/vango-go/vango/el"
)

// HomePage handles the home page (was IndexPage).
func HomePage(ctx vango.Ctx) *vango.VNode {
	return Div(Text("Home"))
}
`
	os.WriteFile(filepath.Join(routesDir, "index.go"), []byte(indexGo), 0644)

	// Create an outdated routes_gen.go that references old handler name
	routesGen := `// Code generated by vango. DO NOT EDIT.

package routes

import "github.com/vango-go/vango/router"

func Register(r *router.Router) {
	r.Page("/", IndexPage) // This references the OLD name
}
`
	os.WriteFile(filepath.Join(routesDir, "routes_gen.go"), []byte(routesGen), 0644)

	// Create go.mod
	goMod := `module test-app

go 1.22
`
	os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goMod), 0644)

	// Create error recovery
	recovery := NewErrorRecovery(tmpDir, routesDir, "test-app")

	// Simulate the build error output
	buildOutput := `./app/routes/routes_gen.go:8:15: undefined: IndexPage`

	// Attempt recovery
	result := recovery.AttemptRecovery(buildOutput)

	// Should have recovered
	if !result.Recovered {
		t.Errorf("Expected recovery, got none. Details: %s", result.Details)
	}

	if result.Action != "regenerated routes_gen.go" {
		t.Errorf("Unexpected action: %s", result.Action)
	}

	// Verify routes_gen.go was regenerated
	newContent, err := os.ReadFile(filepath.Join(routesDir, "routes_gen.go"))
	if err != nil {
		t.Fatalf("Failed to read regenerated routes_gen.go: %v", err)
	}

	// The new file should NOT reference IndexPage (it should reference HomePage)
	if containsString(string(newContent), "IndexPage") {
		t.Errorf("Regenerated routes_gen.go still contains 'IndexPage'")
	}
}

func TestErrorRecovery_NoRecoverableError(t *testing.T) {
	tmpDir := t.TempDir()
	routesDir := filepath.Join(tmpDir, "app", "routes")
	os.MkdirAll(routesDir, 0755)

	recovery := NewErrorRecovery(tmpDir, routesDir, "test-app")

	// Non-recoverable build error
	buildOutput := `./main.go:10:5: cannot use 1 (type int) as type string in assignment`

	result := recovery.AttemptRecovery(buildOutput)

	if result.Recovered {
		t.Errorf("Should not have recovered from non-routes error")
	}
}

func TestGetModulePath(t *testing.T) {
	tmpDir := t.TempDir()

	// Test with valid go.mod
	goMod := `module github.com/example/myapp

go 1.22

require (
	github.com/vango-go/vango v2.0.0
)
`
	os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goMod), 0644)

	modulePath, err := GetModulePath(tmpDir)
	if err != nil {
		t.Fatalf("GetModulePath error: %v", err)
	}

	if modulePath != "github.com/example/myapp" {
		t.Errorf("ModulePath = %q, want %q", modulePath, "github.com/example/myapp")
	}
}

func TestGetModulePath_NoGoMod(t *testing.T) {
	tmpDir := t.TempDir()

	_, err := GetModulePath(tmpDir)
	if err == nil {
		t.Error("Expected error for missing go.mod")
	}
}

// Note: containsString is declared in dev_test.go
