package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
	"github.com/vango-dev/vango/v2/internal/config"
)

func genCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "gen <type>",
		Short: "Generate code",
		Long: `Generate code for routes, components, or other Vango constructs.

Types:
  routes     Generate route registration code
  component  Generate a new component scaffold

Examples:
  vango gen routes
  vango gen component Button
  vango gen component UserCard`,
	}

	cmd.AddCommand(
		genRoutesCmd(),
		genComponentCmd(),
	)

	return cmd
}

func genRoutesCmd() *cobra.Command {
	var output string

	cmd := &cobra.Command{
		Use:   "routes",
		Short: "Generate route registration code",
		Long: `Scan the routes directory and generate route registration code.

This command scans app/routes/ for Go files and generates
the routes.go file that registers all routes with the server.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runGenRoutes(output)
		},
	}

	cmd.Flags().StringVarP(&output, "output", "o", "", "Output file (default: app/routes/routes.go)")

	return cmd
}

func genComponentCmd() *cobra.Command {
	var outputDir string

	cmd := &cobra.Command{
		Use:   "component <name>",
		Short: "Generate a new component",
		Long: `Generate a new component scaffold.

This creates a new Go file with a component function template.

Examples:
  vango gen component Button
  vango gen component UserCard
  vango gen component --output=app/components/ui Header`,
		Args: cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			return runGenComponent(args[0], outputDir)
		},
	}

	cmd.Flags().StringVarP(&outputDir, "output", "o", "", "Output directory (default: app/components)")

	return cmd
}

func runGenRoutes(output string) error {
	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	routesDir := cfg.RoutesPath()
	if output == "" {
		output = filepath.Join(routesDir, "routes.go")
	}

	info("Scanning %s...", routesDir)

	// Scan for route files
	routes, err := scanRoutes(routesDir)
	if err != nil {
		return err
	}

	info("Found %d routes", len(routes))

	// Generate code
	code, err := generateRoutesCode(routes)
	if err != nil {
		return err
	}

	// Write file
	if err := os.WriteFile(output, []byte(code), 0644); err != nil {
		return err
	}

	success("Generated %s", output)
	return nil
}

type scannedRoute struct {
	Path     string
	Handler  string
	File     string
	IsLayout bool
}

func scanRoutes(dir string) ([]scannedRoute, error) {
	var routes []scannedRoute

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(path, ".go") {
			return nil
		}
		if strings.HasSuffix(path, "_test.go") {
			return nil
		}
		if filepath.Base(path) == "routes.go" {
			return nil // Skip the generated file
		}

		relPath, _ := filepath.Rel(dir, path)
		routePath := pathToRoute(relPath)
		handler := pathToHandler(relPath)
		isLayout := strings.HasPrefix(filepath.Base(path), "_layout")

		routes = append(routes, scannedRoute{
			Path:     routePath,
			Handler:  handler,
			File:     relPath,
			IsLayout: isLayout,
		})

		return nil
	})

	return routes, err
}

func pathToRoute(relPath string) string {
	// Remove .go extension
	route := strings.TrimSuffix(relPath, ".go")

	// Convert directory separators to URL path
	route = strings.ReplaceAll(route, string(os.PathSeparator), "/")

	// Handle index files
	if strings.HasSuffix(route, "/index") {
		route = strings.TrimSuffix(route, "/index")
	}
	if route == "index" {
		route = ""
	}

	// Convert [param] to :param
	route = strings.ReplaceAll(route, "[", ":")
	route = strings.ReplaceAll(route, "]", "")

	// Ensure leading slash
	if !strings.HasPrefix(route, "/") {
		route = "/" + route
	}

	return route
}

func pathToHandler(relPath string) string {
	// Remove .go extension
	name := strings.TrimSuffix(filepath.Base(relPath), ".go")

	// Handle index -> Page
	if name == "index" {
		return "Page"
	}

	// Handle [param] -> ParamPage
	if strings.HasPrefix(name, "[") && strings.HasSuffix(name, "]") {
		param := name[1 : len(name)-1]
		return capitalize(param) + "Page"
	}

	// Convert to PascalCase + Page
	return capitalize(name) + "Page"
}

func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func generateRoutesCode(routes []scannedRoute) (string, error) {
	tmpl := `// Code generated by vango gen routes. DO NOT EDIT.
package routes

import "github.com/vango-dev/vango/v2/pkg/server"

// Register registers all routes with the server.
func Register(srv *server.Server) {
{{- range .Routes}}
{{- if not .IsLayout}}
	srv.Get("{{.Path}}", {{.Handler}})
{{- end}}
{{- end}}
}
`

	t, err := template.New("routes").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, map[string]any{"Routes": routes}); err != nil {
		return "", err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.String(), nil
	}

	return string(formatted), nil
}

func runGenComponent(name, outputDir string) error {
	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	if outputDir == "" {
		outputDir = cfg.ComponentsPath()
	}

	// Ensure directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	// Generate filename
	filename := strings.ToLower(name) + ".go"
	outputPath := filepath.Join(outputDir, filename)

	// Check if file exists
	if _, err := os.Stat(outputPath); err == nil {
		return fmt.Errorf("file %s already exists", outputPath)
	}

	// Generate component code
	code := generateComponentCode(name)

	// Write file
	if err := os.WriteFile(outputPath, []byte(code), 0644); err != nil {
		return err
	}

	success("Created %s", outputPath)
	return nil
}

func generateComponentCode(name string) string {
	return fmt.Sprintf(`package components

import (
	. "github.com/vango-dev/vango/v2/pkg/vdom"
	"github.com/vango-dev/vango/v2/pkg/vango"
)

// %s is a component.
func %s() vango.Component {
	return vango.Func(func() *VNode {
		return Div(Class("%s"),
			// Add your component content here
		)
	})
}
`, name, name, strings.ToLower(name))
}
